[TOC]

在`ES6`之前，社区制定了一些模块加载方案，最主要的有`CommonJS`和`AMD`两种。前者用于服务器，后者用于浏览器。`ES6`在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代`CommonJS和AMD`规范，成为浏览器和服务器通用的模块解决方案。

`ES6`模块的设计思想是尽量的静态化，使得**编译时**就能确定模块的依赖关系，以及输入和输出的变量。`CommonJS和AMD`模块，都只能在**运行时**确定这些东西。比如，`CommonJS`模块就是对象，输入时必须查找对象属性。
>`CommonJS`模块:
```js
let { stat, exists, readFile } = require('fs');

// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```
上面代码的实质是整体加载`fs`模块（即加载`fs`的所有方法），生成一个对象`_fs`，然后再从这个对象上面读取`3`个方法。这种加载称为“**运行时加载**”，因为只有运行时才能得到这个对象，导致完全没办法在**编译时**做“静态优化”。

`ES6`模块不是对象，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入。
>`ES6`模块：
```js
import { stat, exists, readFile } from 'fs';
```
上面代码的实质是从`fs`模块加载`3`个方法，其他方法不加载。这种加载称为“**编译时加载**”或者**静态加载**，即`ES6`可以在编译时就完成模块加载，效率要比`CommonJS`模块的加载方式高。

>特别说明：`ES6`的模块自动采用严格模式，不管你有没有在模块头部加上`"use strict";`。

#### export命令
`ES6`模块功能主要由两个命令构成：`export和import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。